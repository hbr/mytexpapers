\documentclass[12pt]{article}
\usepackage{amsmath,amsthm,amssymb,xcolor,graphicx,tikz,listings}
\usepackage[pdftex]{hyperref}
\usetikzlibrary{positioning}

\def\blank{\llcorner\!\!\lrcorner}
\def\class{\text{class}}
\def\create{\text{create}}
\def\cs{\text{cs}}
\def\fits{\text{fits}}
\def\kwend{\text{end}}
\def\GS{\,[\![\,}
\def\GE{\,]\!]\,}
\def\IS{\text{IS}}
\def\IE{\text{IE}}
\def\Natural{\text{Natural}}

\newcommand{\group}[1]{\GS #1 \GE}
\newcommand{\flatten}[1]{\overline{#1}}

%Double Brackets
% [[             [\![
% ]]             ]\!]



\lstdefinelanguage{alba}
{ basewidth=0.45em,
  basicstyle=\scriptsize\tt,
  %columns=flexible,
  keywords={all,case,class,create,else,end,if,inspect,then},
  keywordstyle=\color{blue},
  commentstyle=\color{brown},
  morecomment=[l]{--},
  morecomment=[n]{\{:}{:\}}
}

\lstnewenvironment{alba} {\lstset{language=alba}} {}

\lstdefinelanguage{ocaml}
{ basewidth=0.45em,
  basicstyle=\scriptsize\tt,
  %columns=flexible,
  keywords={
    and,assert,do,done,else,end,for,fun,functor,if,in,include,
    let,module,mutable,rec,sig,struct,then,to,type,val},
  keywordstyle=\color{blue},
  commentstyle=\color{brown},
  morecomment=[n]{(*}{*)}
}

\lstnewenvironment{ocaml} {\lstset{language=ocaml}} {}




\begin{document}



\title{Pretty Printing}
\author{Helmut Brandl \\ \scriptsize (firstname dot lastname at gmx dot net)}
\date{}

\maketitle

\abstract{A pretty printing algorithm is described which is suitable to be
  implemented in any strict language. An example implementation in Ocaml is
  given. }


\tableofcontents



\section{Introduction}

Pretty printing is the inverse of parsing. Parsing breaks up a sequence of
characters (or tokens) into a syntax tree, pretty printing formats a tree
structured document into a stream of characters. A pretty printer shall format
the output in a way to make it as readable as possible i.e. to add line breaks
and indentation to make the structure of the document visible.

As opposed to parsing, pretty printing is not covered a lot in the computer
science literature. Pretty printing is mainly addressed in articles describing
the implementation of a pretty printer in a lazily evaluated languages like
Miranda or Haskell e.g. in Hughes(1995)~\cite{hughes1995} or
Wadler(2003)~\cite{wadler}.

Lazy evaluation allows a very elegant formulation of pretty printing. However
lazy evaluation has the drawback that it is easy to generate stack overflows
or deadlocks. It requires a lot of experience to get complex algorithms right
in lazily evaluated languages, even very experienced programmers sometime step
into the pitfalls of lazy evaluation.

Furthermore an algorithm written for lazy evaluation, if executed strictly,
might be very inefficient. For this reason a pretty printing algorithm is
needed which performs well in strict languages.

In this article a state based pretty printing algorithm is described which can
be proved to be correct and efficient in strict languages and an example
implementation is given in Ocaml. The algorithm makes the same formatting
decisions as the algorithm described in Wadler(2003)~\cite{wadler}.


\section{Examples}


Let's consider a definition of an inductive data type in Alba.
\begin{alba}
    class
        Natural
    create
        0
        succ(Natural)
    end
\end{alba}
%
The programming language is not important here. You can certainly come up with
a similar example in your favourite programming language.

This printing nicely shows the structure of the definition. The declaration
declares a type and two constructors to construct elements of the
type. However the presentation of the declaration consumes a lot of lines.
There are several possibilities to present the same declaration.
%
\begin{alba}
    class Natural create 0; succ(Natural) end
\end{alba}
%
or less compressed
\begin{alba}
    class Natural create
        0
        succ(Natural)
    end
\end{alba}
%
or
%
\begin{alba}
    class Natural create
        0; succ(Natural)
    end
\end{alba}
%
%
The choice of the \emph{best} presentation is a matter of taste.  We have two
tools to display structure:
\begin{itemize}
\item Line breaks
\item Indentation
\end{itemize}









\section{Simple Layouts}

In order to describe the structure of a document we use the following grammar
$$
\begin{array}{llll}
  d &::=& T_s      & \text{text with the string } s
  \\
    & \mid & L     & \text{line break}
  \\
    & \mid & d\, d & \text{concatenation of two documents}
  \\
    & \mid & d^i   & \text{additional indentation $i$ after newlines in } d
\end{array}
$$%
%
The structure of the above declaration of the type of natural numbers
\begin{alba}
    class
        Natural
    create
        0
        succ(Natural)
    end
\end{alba}
%
can be expressed by the document
$$
\begin{array}{l}
  T_\class \,
  \\
  (L \, T_\Natural)^4 \, \\
  L \, T_\create \, \\
  (L \, T_0 \, L \, T_\text{succ(Natural)})^4 \\
  \, L \, T_\text{end}
\end{array}
$$%

In a language with the 3 commands
$$
\begin{array}{llll}
  c & ::= & T_s         & \text{text block with string } s
  \\
    & \mid &  L         & \text{line break}
  \\
    & \mid &  I_i     & \text{increment indentation by } i
\end{array}
$$%
we can express the same document structure with the sequence of commands
$$
\begin{array}{l}
  T_\class\, \\
  I_4\, L\, T_\Natural\, I_{-4}\, \\
  L\, T_\create\, \\
  I_4\, L\, T_0\, L\, T_\text{succ(Natural)}\, I_{-4} \\
  L\, T_\kwend
\end{array}
$$

It is easy to convert a document into a list of commands
{\def\coms{\text{list}}
  $$
  \text{\coms(d)} :=
  \begin{cases}
    \coms(T_s) &:= [T_s]
    \\
    \coms(L) &:= [L]
    \\
    \coms(x y) &:= \coms(x) + \coms(y)
    \\
    \coms(x^i) &:= [I_i] + \coms(x) + [I_{-i}]
  \end{cases}
  $$
}
where the operator $+$ is used to express list concatenation.

In order to convert a command sequence into actual printing commands we need a
state which represents current indentation level. We process the commands as
follows:
\begin{enumerate}
\item $T_s$: Print the string $s$.

\item $L$: Print a line break plus $n$ blanks where $n$ is the current
  indentation level.

\item $I_i$: Increment the current indentation level by $i$ (or decrement in
  case $i$ is negative.
\end{enumerate}





\section{Multiple Layouts}

In the previous chapter we described a pretty printer which converted a
sequence of the commands $T_s$, $L$ and $I_i$ into actual printing
commands. The described pretty printer had no choices to make, just maintain
an indentation level. This is due to the fact that our description of the
layout did not allow any choices. The description of the layout forced a
certain sequence of actual printing commands.




\subsection{Description of Multiple Layouts}

In order to add choices to the description of a layout we add two elements.

\begin{itemize}

\item Break hints: We treat each line break just as a break hint and add some
  alternative string to the line break. The pretty printer has the choice to
  print the line break as an actual line break followed by indentation blanks
  or use the alternative string and print it on the current line.

\item Grouping: We indicate to the pretty printer which parts of the document
  can be squeezed on a line using the alternative text of the line breaks. All
  line breaks belonging directly to the group (and not to subgroups) are
  interpreted consistently i.e. either as effective line breaks or as its
  alternative text.
\end{itemize}

Usually the alternative text of a line break is a blank. For programming
language constructs we can choose a semicolon followed by a black as an
alternative text.

We use the following grammar to describe documents:
$$
\begin{array}{llll}
  d &::=& T_s     & \text{text with the string } s
  \\
    & \mid & L_s  & \text{line break with alternative text } s
  \\ & & &\text{default: blank}
  \\
    & \mid & d\, d & \text{concatenation of two documents}
  \\
    & \mid & d^i   & \text{additional indentation $i$
                     after newlines in } d\, (i \ge 0)
  \\
    & \mid & \group{d} & \text{allow flattened version of $d$ as an
                         alternative layout}
\end{array}
$$%
and use the following function to flatten a document
$$
\flatten{d} :=
\begin{cases}
  \flatten{T_s} &:= T_s
  \\
  \flatten{L_s} &:= T_s
  \\
  \flatten{x\, y} &:= \flatten{x} \, \flatten{y}
  \\
  \flatten{x^i} &:= \flatten{x}
  \\
  \flatten{\group{x}} &:= \flatten{x}
\end{cases}
$$
%
Inside a flattened document all line breaks are substituted by the
corresponding alternative text, all indentations can be removed because there
are no more line breaks in the flattened document and all groups within a
flattened document are no longer important and can be removed as well.

In order to express the document as a command sequence we need one more
command to start a group and one more command to end a group.
%
$$
\begin{array}{llll}
  c & ::= & T_s         & \text{text block with string } s
  \\
    & \mid &  L_s       & \text{line break with alternative text } s
  \\ & & &\text{default: blank}
  \\
    & \mid &  I_i     & \text{increment indentation by } i
  \\
    & \mid &  \GS       & \text{start a group }
  \\
    & \mid &  \GE       & \text{end a group }
\end{array}
$$%
We can convert a document to a command list by the function
{\def\cs{\text{list}}
  $$
  \cs(d) :=
  \begin{cases}
    \cs(T_s) & := [T_s]
    \\
    \cs(L_s) & := [ L_s ]
    \\
    \cs(x\, y) & := \cs(x) + \cs(y)
    \\
    \cs(x^i)   & := [I_i] + \cs(x) + [I_{-i}]
    \\
    \cs(\group{x})  & := [\GS] + \cs(x) + [\GE]
  \end{cases}
  $$%
  where $+$ is used for list concatenation.
}
%
A command list is valid if there exists a document such that the document
generates the command list. Therefore in a valid command list all groups and
indentation blocks are correctly nested and the indentation levels are
correctly incremented and decremented.


\subsection{Example}

We illustrate the description with our example of an inductive type for
natural numbers
\begin{alba}
    class
        Natural
    create
        0
        succ(Natural)
    end
\end{alba}
In order to make it possible that the whole declaration is displayed on a
single line we have to enclose all into a group. If we want that the printing
can start with
\begin{alba}
    class Natural create
\end{alba}
%
we have to group these items as well. Furthermore we need one other group to
have the possibility that all constructors can appear on a line.

The following command sequence allows all these alternatives
$$
\begin{array}{l}
  \GS \, \\
  \quad \GS \, T_\class\,
     I_4\, L\, T_\Natural\, I_{-4}\,
  L\, T_\create\, \GE
  \\
  \quad I_4\, L\, \GS\,
  T_0\, L_{;\blank} \, T_\text{succ(Natural)}\,
  \GE\, I_{-4} \\
  \quad L \, T_\kwend \, \\
  \GE
\end{array}
$$



\subsection{Selection of a Layout}

In order to select a layout from a command sequence describing a multiple
layout we have to decide which groups we want to flatten and which groups we
do not want to flatten i.e. where all line breaks belonging directly to the
group remain effective.

We use the letter $F$ for a flattened group and the letter $E$ for a group
with effective line breaks and a sequence of these letters e.g. $FEEEFF\ldots$
to indicate which of the groups reading the command sequence left to right are
flattened and which are effective. If a group is flattened, the inner groups
are flattened as well.

Let's see how a the sequence of letters controls the formatting of our example
of natural numbers.
\begin{enumerate}
\item $FFF$: The first group is flattened. All other groups are inner groups
  and are therefore flattened implicitly.
  \begin{alba}
    class Natural create 0; succ(Natural) end
  \end{alba}

\item $NFF$: The outer group is not flattened. The inner groups are flattened.
  \begin{alba}
    class Natural create
        0; succ(Natural)
    end
  \end{alba}

\item $NFN$: The outer group is not flattened. The first inner group is
  flattened and the next is not flattened.
  \begin{alba}
    class Natural create
        0
        succ(Natural)
    end
  \end{alba}

\item $NNF$: The outer group is not flattened. The first inner group is
  not flattened and the next is flattened.
  \begin{alba}
    class
        Natural
    create
        0; succ(Natural)
    end
  \end{alba}

\item $NNN$: No groups are flattened.
  \begin{alba}
    class
        Natural
    create
        0
        succ(Natural)
    end
  \end{alba}

\end{enumerate}

If there are $n$ groups in a command sequence there are at most $2^n$ possible
layouts. However the actual number of possibilities is ususally smaller,
because the choices of inner groups are possible only if the outer group is
effective.

In our example there are 2 inner groups which have $2^2 = 4$
possibilities. The outer group adds just one more possibility therefore we
have $2^2 + 1 = 5$ possibilities to format the text.


\subsection{Choosing the Best Layout}
\label{bestlayout}

Choosing the \emph{best} layout is equivalent to choosing a selection string
of letters $F$ and $E$ of the groups encountered in the left to right reading
of a command sequence. In this section we want to define the \emph{best}
selection string.

A selection string is complete if it decides all groups in the command
sequence. A selection string is partial if it is a prefix (proper or not
proper) of a complete selection string. Note that according to this definition
a complete selection string is a partial selection string as well.

An active group for a partial selection string is the first group in the
command sequence which is not yet decided.

A partial selection string is complete if it has no more active group. It is
incomplete if there is an active group.

An empty selection string is always a partial selection string for any command
sequence.

For an incomplete partial selection string we can partition the command
sequence uniquely into a head part, an active part and a tail part
$$
\text{cs} = h \quad a \quad t
$$
where $a$ is the longest subsequence which
\begin{enumerate}
\item contains the active group

\item contains no effective line breaks to the left of the group (an effective
  line break is a line break which does not belong to a flattened group)

\item contains no line breaks to the right of the group
\end{enumerate}
We can illustrate the splitting graphically by
{
  \newcommand{\mline}[1]{\text{\rule{#1mm}{1mm}}}
    $$%
    \begin{array}{l}
      \underbrace{
      \begin{array}{l}
        \mline{20} \\
        \quad\mline{30}\\
        \quad\mline{20}\\
        \mline{20} \\
        \quad\mline{30}L
      \end{array}}_h
      \\
      \\
      \underbrace{\text{\framebox[10mm][c]{i}}}_\text{indentation}
      \underbrace{\quad \cdots \quad
         \underbrace{\GS\cdots\GE}_\text{active group}
      \quad \cdots \quad}_a \quad
      \underbrace{L \quad \ldots}_t

    \end{array}
    $$
}
Due to the definitions we can make the following observations:
\begin{itemize}
\item The head part $h$ contains only groups which are already
  decided. Therefore the layout is fixed. It can be empty or must end in an
  effective line break.

\item If the head part is empty, then the indentation level $i$ is $0$. If the
  head part is not empty then its terminating line break belongs to a certain
  indentation level $i$. Therefore the active part $a$ always starts on a
  fresh line with a certain indentation level $i$.

\item The active part $a$ might contain to the left of the active group some
  groups which are already decided. But these groups must not contain
  effective line breaks i.e. are either flattened or do not have line breaks.

\item The active part $a$ might contain to the right of the active group some
  other groups (or parts of them), but only parts of the groups which do not
  have any line break.

\item The tail part is either empty or starts with a line break.
\end{itemize}


Now we have to make the decision whether we flatten the active group or
not. Recall that flattening the active group implies flattening of all inner
groups implicitly.

We certainly don't want the printed text to exceed the desired line width
$w$. I.e. one condition is $i + |a| \le w$ where $|a|$ is the width of the
flattened active region $a$. A further condition might be that the the printed
text after the indentation does not exceed a certain ribbon width $r$
i.e. $|a| \le r$. I.e. we flatten the active group only if
$$
i + |a| \le w \land |a| \le r
$$
is satisfied. Note that in case $w \le r$ the first condition implies the
second.

If we start with an empty selection string and decide the active group, then
step by step we can construct a complete selection string for the given
command sequence. The procedure terminates if there is no more active group to
decide.


\subsection{Best Layout: Example}

Consider the command sequence of our example.
$$
\begin{array}{l}
  \GS \, \\
  \quad
  \GS \, T_\class\,
     I_4\, L\, T_\Natural\, I_{-4}\,
  L\, T_\create\, \GE
  \\
  \quad I_4\, L\,
  \GS\, T_0\, L_{;\blank}\, T_\text{succ(Natural)}\, \GE\,
  I_{-4} \\
  \quad L \, T_\kwend \, \\
  \GE
\end{array}
$$
%
We try to find a selection string for a line and ribbon width of $20$.

Starting with an empty partial selection string we get a partition where $h$
is empty, $a$ contains the whole command sequence and $t$ is empty. Since $|a|
> 20$ the first group is not flattened and the next partial selection string
is $E$.


For the partial selection string $E$ we get the partition
$$
\begin{array}{lll}
  h &=& \epsilon
  \\
  a &=& \GS \,
        \underbrace{
        \GS \, T_\class\,
        I_4\, L\, T_\Natural\, I_{-4}\, L \, T_\create\, \GE
        }_{\text{second group}} \, I_4
  \\
  t  & = &  L\,
           \GS\, T_0\, L_{;\blank}\, T_\text{succ(Natural)}
           \GE \, I_{-4}\, \\
    & & L \, T_\kwend \, \GE
  \\
  \text{with} \\
  i & = & 0
  \\
  |a| & = & 20 %5 + 1 + 7 + 1 + 6
\end{array}
$$%
Since $i + |b| \le 20$ the second group is flattened and we get the selection
string $EF$.

For the partial selection string $EF$ we get the partition
$$
\begin{array}{lll}
  h &=& \GS \,
        \GS \, T_\class\,
        I_4\, L\, T_\Natural\, I_{-4}\, L \, T_\create\, \GE \, I_4\, L
  \\
  a &=& \underbrace{
        \GS \,T_0\, L_{;\blank}\, T_\text{succ(Natural)}\, \GE
        }_{\text{third group}}
        \, I_{-4}
  \\
  t & = & L \, T_\kwend \, \GE
  \\
  \text{with}
  \\
  i & = & 4
  \\
  |a| & = & 16%
\end{array}
$$%
Since $i + |a| \le 20$ the line width is not exceeded and the third group is
flattened. We get the complete selection string $E F F$ and the layout
\begin{alba}
    class Natural create
        0; succ(Natural)
    end
\end{alba}



\section{Efficient Algorithm}


\paragraph{Basic Idea}
In order to decide to flatten or to not flatten a group we have to check the
critierion
$$
\fits(a) := i + |a| \le w \land |a| \le r
$$%
where $a$ is the active region, $i$ is the indentation of the current line,
$w$ is the desired maximal line width and $r$ is the desired maximal ribbon
width.

The easiest brute force algorithm is to read the whole active region into a
buffer and evaluate $\fits(a)$. Such an algorithm would be terribly
inefficient because the active region might be the whole document and after
each decision of a group the next active region would have to be evaluated
which might require a reevaluation of the previous active region.

There are two facts which make our life easier:
\begin{enumerate}
\item If a prefix of the active region already violates the criterion there is
  no need to scan the whole active region.

\item If the active region satisfies the criterion, then the active region is
  not longer than a line.
\end{enumerate}
%
I.e. we have to buffer at most a complete line to make a decision for the
active group.




\paragraph{Normalization}
Grouping is relevant only for the line breaks within a group, because the line
breaks belonging directly to a group must be interpreted consistently
i.e. either all effective of all flattened. However text blocks are always
printed, regardless if they belong to a group or not. Therefore we have the
following equivalences
$$
\begin{array}{lll}
  \ [\![T \ldots]\!] &\sim&  T [\![\ldots]\!]
  \\
  \ [\![\ldots]\!] T &\sim&  [\![\ldots T]\!]
%  [\![\ldots]\!] T &\sim&   [\![\ldots T]\!]

\end{array}
$$
%
The first lets us open groups in the buffer as late as possible and the second
allows to close groups in the buffer as late as possible.


\paragraph{Data of the state} The algorithm works with the following state
data:
\begin{enumerate}
\item $i$: Indentation of the current line.

\item $j$: Current indentation level.

\item $p$: Position on the current line at the start of the buffer.

\item $o_e$: Number of open effective groups

\item $o_a$: Number of open active groups

\item $o_r$: Number of open groups to the right of the last group in the
  buffer

\item $o_b$: Number of open groups in the buffer (incomplete groups)

\item $b = g^\bullet_0 g^\bullet_1 \ldots$: Buffer of incomplete groups
\end{enumerate}
%
with the grammar
$$
\begin{array}{lll}
  g & ::= & [\![ g^* c^* ]\!]
  \\
  c & ::= & l\, t^* g^*
  \\
  g^\bullet & ::= & [\![ g^* c^*
\end{array}
$$
where $g$ ranges over groups, $g^\bullet$ over incomplete groups,
$c$ over chunks, $l$ over line breaks and
$t$ over text blocks. Within the line break we store the alternative text and
the indentation level valid at the line break.

Because of normalization no group in the buffer will start with a text
block. All text block starting a group will be pulled out of the
group. Therefore a group in the buffer can only start with zero or more
complete inner groups followed by zero or more chunks.

Each chunk of a group starts with a line break belonging directly to the
group, followed by a sequence of zero or more text blocks, followed by zero or
more complete groups.

The buffer is a sequence of incomplete groups.



\paragraph{Actions in buffering mode}
\begin{itemize}
\item We open the first group only at a line break within the active group. We
  have to open $o_a$ groups which means we have to open $o_a - 1$ empty groups
  and the group starting with a line break i.e. having a chunk.

\item A line break with $o_a = 0$ ends buffering mode and the buffer has to be
  flushed flattening all groups it contains.

\item Another line break within the last group just starts a new chunk in the
   last group.

 \item Another line break within an inner group of the last group opens
   $o_a - o_b$ new groups where $o_b$ is the number of open groups in the
   buffer. The innermost group is the new last group.


\item A line break in a group to the right of the last group group (but still
  inside the active group) closes $o_b - o_a$ groups, and opens $o_r$ groups
  in the buffer. We set $o_a := o_a + o_r$ and $o_r := 0$.
\end{itemize}



\section{Implementation in Ocaml}

First some basic data types:
\begin{ocaml}
  type alternative_text = string
  type start = int
  type length = int
  type indent = int
  type width  = int
  type ribbon = int
  type position = int
  type open_groups = int

  module Text =
    struct
      type t = {s:string; i0:start; l:length}
      let make s i0 l = {s;i0;l}
      let string t = t.s
      let start t = t.i0
      let length t = t.l
    end

  module Line =
    struct
      type t = {s:alternative_text; i:indent}
      let make s i = {s;i}
      let text (l:t): alternative_text = l.s
      let length l = String.length l.s
      let indent l = l.i
    end
\end{ocaml}
%
Note that we allow text blocks consisting of substrings of a string in order
to avoid copying of substrings. A line break consists of its alternative text
and the indentation level valid at the line break.

Next we define structures for groups and chunks:
\begin{ocaml}
  type chunk = {clen: length;
                line: Line.t;
                texts:  Text.t list;
                cgroups: group list}

  and group = {len:length;
               groups: group list;
               chunks: chunk list}

  module Chunk =
    struct
      let length (c:chunk): length = c.clen
      let alternative_text (c:chunk): alternative_text = Line.text c.line
      let groups (c:chunk): group list = c.cgroups
      let texts (c:chunk): Text.t list = c.texts
      let make (line:Line.t): chunk =
        {clen = Line.length line; line; texts = []; cgroups = []}
      let add_text (t:Text.t) (c:chunk): chunk =
        assert (c.cgroups = []);
        {c with clen = c.clen + t.Text.l; texts = t :: c.texts}
      let add_group (g:group) (c:chunk): chunk =
        {c with clen = g.len + c.clen; cgroups = g :: c.cgroups}
    end


  module Group =
    struct
      let length (g:group): length =  g.len
      let empty = {len = 0; groups = []; chunks = []}
      let groups (g:group): group list = g.groups
      let chunks (g:group): chunk list = g.chunks
      let of_line (l:Line.t): group =
        let c = Chunk.make l in
        {len = Chunk.length c; groups = []; chunks = [c]}
      let add_text (t:Text.t) (g:group): group =
        match g.chunks with
        | [] ->
           assert false (* Illegal call *)
        | c :: tl ->
           {g with len = g.len + t.Text.l; chunks = Chunk.add_text t c :: tl}
      let add_line (l:Line.t) (g:group): group =
        {g with
          len = g.len + String.length l.Line.s;
          chunks = Chunk.make l :: g.chunks}
      let add_group (gi:group) (go:group): group =
        let len = go.len + gi.len
        in
        match go.chunks with
        | [] ->
           {go with len; groups = gi :: go.groups}
        | c :: cs ->
           {go with len; chunks = Chunk.add_group gi c :: cs}
    end
\end{ocaml}
%
For efficiency reasons the length of the groups and chunks are stored within
the structures and are updated consistently. Furthermore the lists are all
stored in reverse order in order to easily push additional data into the
structures.

A buffer consists of a (reversed) list of incomplete groups, the length of the
whole buffer and the number of open groups within the buffer. The latter two
are there for efficiency reasons.
\begin{ocaml}
  module Buffer =
    struct
      type t = {gs: group list;
                l:  length;
                o:  open_groups}

      let is_empty (b:t): bool = (b.o = 0)
      let length (b:t): length = b.l
      let count (b:t): open_groups = b.o
      let groups (b:t): group list = b.gs
      let empty: t =
        {gs = []; l = 0; o = 0;}
      let push (g:group) (b:t): t =
        {gs = g :: b.gs; l = Group.length g + b.l; o = b.o + 1}
      let one (g:group): t =
        push g empty
      let add_text (t:Text.t) (b:t): t =
        let open Text in
        match b.gs with
        | [] ->
           assert false (* Illegal call *)
        | g :: tl ->
           {b with
             gs = Group.add_text t g :: tl;
             l  = b.l + t.Text.l}
      let add_line (l:Line.t) (b:t): t =
        match b.gs with
        | [] ->
           assert false (* Illegal call *)
        | g :: tl ->
           {b with
             gs = Group.add_line l g :: tl;
             l  = b.l + Line.length l}
      let open_groups (n:int) (b:t): t =
        assert (0 <= n);
        let rec ogs n gs =
          if n = 0 then
            gs
          else
            Group.empty :: ogs (n-1) gs
        in
        {b with o = b.o + n; gs = ogs n b.gs}
      let close_groups (n:int) (b:t): t =
        assert (0 <= n);
        assert (n < b.o);
        let rec close n gs =
          if n = 0 then
            gs
          else
            match gs with
            | gi :: go :: tl ->
               close
                 (n-1)
                 (Group.add_group gi go :: tl)
            | _ ->
               assert false (* Illegal call: cannot close group unless there is
                               one group to which it can be added. *)
        in
        {b with o = b.o - n; gs = close n b.gs}
    end
\end{ocaml}
%
Note that the commands to open and close groups open only and close only empty
groups so that the total length of the buffer does not change. Only the
functions to add text and add line breaks add data to the buffer.


The pretty printer needs a printing monad with the interface
\begin{ocaml}
  module type PRINTER =
    sig
      val make:  'a -> 'a t
      val (>>=): 'a t -> ('a -> 'b t) -> 'b t

      val putc: char -> unit t
      val put_string: string -> unit t
      val put_substring: string -> int -> int -> unit t
      val fill: char -> int -> unit t
    end
\end{ocaml}
to actually print characters, strings etc. and satisfies the monadic interface
\begin{ocaml}
  module type PRETTY =
    sig
      val make:  'a -> 'a t
      val (>>=): 'a t -> ('a -> 'b t) -> 'b t

      val text_sub: string -> start -> length -> unit t
      val text: string -> unit t
      val line: alternative_text -> unit t
      val nest: indent -> 'a t -> unit t
      val group: 'a t -> unit t
    end
\end{ocaml}
%
The pretty printing module is a functor with the structure
\begin{ocaml}
  module Make:
    functor (P:PRINTER) ->
    sig
      include PRETTY
      val run: indent -> width -> ribbon -> 'a t -> unit P.t
    end =
    functor (P:PRINTER) ->
    struct
      type state = ... (* see below *)

      type 'a t = state -> 'a P.t
      let make (a:'a) (st:state): 'a P.t = P.make a
      let (>>=) (m:'a t) (f:'a -> 'b t) (st:state): 'b P.t =
        P.(m st >>= fun a -> f a st)
    ...
    end
\end{ocaml}
%
Now we define the type for the state and some functions accessing the state.
\begin{ocaml}
    type state = {
        width: int;                (* desired maximal line width *)
        ribbon: int;               (* desired maximal ribbon width *)
        mutable line_indent: indent;
        mutable current_indent: indent;
        mutable p: position;       (* on current line at start of buffer *)
        mutable oe:  open_groups;  (* effective *)
        mutable oa:  open_groups;  (* active *)
        mutable o_r: open_groups;  (* to the right of the last open group in
                                      buffer *)
        mutable b: Buffer.t
      }


    let init (i:indent) (width:int) (ribbon:int): state =
      {line_indent = i; current_indent = i;
       width; ribbon;
       p = i;
       oe = 0; oa = 0; o_r = 0;
       b = Buffer.empty}

    let normal (st:state): bool =
      Buffer.is_empty st.b

    let buffering (st:state): bool =
      not (Buffer.is_empty st.b)

    let fits_pos (p:position) (st:state): bool =
      p <= st.width
      && p - st.line_indent <= st.ribbon

    let fits (len:int) (st:state): bool =
      fits_pos (st.p + (Buffer.length st.b) + len) st

    let buffer_fits (st:state): bool =
      fits 0 st

    let active_to_effective (st:state): unit =
      (* Make all active groups effective *)
      assert (normal st);
      st.oe <- st.oe + st.oa;
      st.oa <- 0
\end{ocaml}
%
Some basic processing functions
\begin{ocaml}
    let state (st:state): state P.t =
      P.make st

    let print_nothing: unit P.t =
      P.make ()

    let print_list (l:'a list) (f:'a -> unit t): unit t =
      List.fold_right
        (fun a pr -> pr >>= fun _ -> f a)
        l (make ())

    let out_text (s:string) (start:start) (len:length) (st:state): unit P.t =
      st.p <- st.p + len;
      P.put_substring s start len

    let rec out_texts (l:Text.t list): unit t =
      print_list
        l
        (fun t ->
          let open Text in
          out_text t.s t.i0 t.l)

    let out_alternative_text (l:Line.t): unit t =
      let s = Line.text l in
      out_text s 0 (String.length s)

    let out_line (i:indent) (st:state): unit P.t =
      st.p <- i;
      st.line_indent <- i;
      P.(putc '\n' >>= fun _ -> fill ' ' i)


    let line_normal (s:alternative_text) (st:state): unit P.t =
      assert (normal st);
      assert (Buffer.is_empty st.b);
      if 0 < st.oa && fits (String.length s) st then
        (* Start buffering *)
        (st.b <-
           Buffer.open_groups st.oa st.b
           |>  Buffer.add_line (Line.make s st.current_indent);
         st.o_r <- 0;
         print_nothing)
      else
        (active_to_effective st;
         out_line st.current_indent st)
\end{ocaml}
%
Next we need some functions to print the buffer's content in flattened mode.
\begin{ocaml}
    let rec flush_flatten_group (g:group): unit t =
      flush_flatten_groups g.groups >>= fun _ ->
      flush_flatten_chunks g.chunks

    and flush_flatten_groups (gs:group list): unit t =
      List.fold_right
        (fun g pr -> pr >>= fun _ -> flush_flatten_group g)
        gs
        (make ())

    and flush_flatten_chunks (cs:chunk list): unit t =
      print_list cs flush_flatten_chunk

    and flush_flatten_chunk (c:chunk): unit t =
      out_alternative_text c.line >>= fun _ ->
      out_texts c.texts >>= fun _ ->
      flush_flatten_groups c.cgroups

    let flush_flatten: unit t =
      state >>= fun st ->
      print_list (Buffer.groups st.b) flush_flatten_group >>= fun _ ->
      st.b <- Buffer.empty;
      make ()
\end{ocaml}
%
Complete groups at the start of the buffer can be decided immediately and
flushed by the functions
\begin{ocaml}
    let rec flush_group (g:group) (st:state): unit P.t =
      (* complete group *)
      if fits (Group.length g) st then
        flush_flatten_group g st
      else
        st
        |> (flush_groups g.groups >>= fun _ ->
            flush_chunks g.chunks)
    and flush_chunk (c:chunk): unit t =
      out_line (Line.indent c.line) >>= fun _ ->
      out_texts c.texts >>= fun _ ->
      flush_groups c.cgroups
    and flush_groups (gs:group list): unit t =
      print_list gs flush_group
    and flush_chunks (cs:chunk list): unit t =
      print_list cs flush_chunk
\end{ocaml}
If the buffer does not fit on a line the following function can be used to
flush groups until the rest of the buffer fits.
\begin{ocaml}
    let flush_effective (st:state): unit P.t =
      (* Flush open groups until buffer fits or is empty. *)
      let flush_incomplete o g st =
        if 0 < st.oa then
          (st.oa <- st.oa - 1;
           st.oe <- st.oe + 1)
        else if o = 0 then
          (* The last incomplete group in the buffer is flushed as well, all
             open groups to the left of the last group become new active
             groups. *)
          (st.oa <- st.o_r;
           st.o_r <- 0);
        (flush_groups g.groups >>= fun _ ->
         flush_chunks g.chunks) st
      in
      let rec flush l o gs st =
        match gs with
        | [] ->
           assert false (* Illegal call *)
        | [g] ->
           assert (not (fits (Group.length g + l) st));
           (* If the first group fitted, then there would be no need to flush
              the group as effective. *)
           flush_incomplete o g st
        | g :: gs ->
           let len =  Group.length g + l in
           P.(flush len (o+1) gs st >>= fun _ ->
              if fits len st then
                (st.b <- Buffer.push g st.b;
                 print_nothing)
              else
                (assert (Buffer.is_empty st.b);
                 flush_incomplete o g st))
      in
      let gs = Buffer.groups st.b in
      st.b <- Buffer.empty;
      flush 0 0 gs st
\end{ocaml}
The rest are some straightforward functions to implement the commands for text
blocks, line breaks, nesting and groups
\begin{ocaml}
    let text_sub (s:string) (start:int) (len:int) (st:state): unit P.t =
      assert (0 <= start);
      assert (start+len <= String.length s);
      if normal st then
        out_text s start len st
      else
        (st.b <- Buffer.add_text (Text.make s start len) st.b;
         if buffer_fits st then
           print_nothing
         else
           flush_effective st)

    let text (s:string): unit t =
      text_sub s 0 (String.length s)

    let rec line (s:alternative_text) (st:state): unit P.t =
      if normal st then
        line_normal s st
      else if 0 < st.oa then
        (* Still inside the active group. *)
        (let o = Buffer.count st.b in
         if st.oa <= o then
           st.b <- Buffer.close_groups (o - st.oa) st.b;
         st.b <-
           (let n = if o < st.oa then st.oa - o else st.o_r in
            Buffer.open_groups n st.b
            |> Buffer.add_line (Line.make s st.current_indent));
         st.oa  <- st.oa + st.o_r;
         st.o_r <- 0;
         if buffer_fits st then
           print_nothing
         else
           flush_effective st
        )
      else
        (* Outside the active group. *)
        (assert (buffer_fits st);
         st.oa <- st.o_r;
         st.o_r <- 0;
         st |> (flush_flatten >>= fun _ -> line s))

    let nest (i:int) (m:'a t): unit t =
      let start st =
        st.current_indent <- st.current_indent + i;
        print_nothing
      and close st =
        assert (i <= st.current_indent);
        st.current_indent <- st.current_indent - i;
        print_nothing
      in
      start >>= fun _ -> m >>= fun _ -> close

    let group (m:'a t): unit t =
      let start st =
        if st.oa < Buffer.count st.b then
          st.o_r <- st.o_r + 1
        else
          st.oa <- st.oa + 1;
        print_nothing
      and close st =
        if 0 < st.o_r then
          (assert (st.oa < Buffer.count st.b);
           st.o_r <- st.o_r - 1)
        else if 0 < st.oa then
           st.oa <- st.oa - 1
        else
          (assert (0 < st.oe);
           st.oe <- st.oe - 1);
        print_nothing
      in
      start >>= fun _ ->
      m >>= fun _ ->
      close
\end{ocaml}
%
And finally we define a function to run the pretty printing monad with a
specific start indentation a line width and a ribbon width
\begin{ocaml}
    let run (indent:int) (width:int) (ribbon:int) (m:'a t): unit P.t =
      let st = init indent width ribbon in
      P.(m st >>= fun _ ->
         if buffering st then
           flush_flatten st
         else
           print_nothing)
\end{ocaml}

For completeness we include an example of a printer monad which prints all
output to a certain output channel
\begin{ocaml}
  module Printer:
  sig
    include PRINTER
    val run: out_channel -> 'a t -> 'a
  end =
    struct
      type 'a t = out_channel -> 'a
      let make (a:'a) (oc:out_channel): 'a = a
      let (>>=) (m:'a t) (f:'a -> 'b t) (oc:out_channel): 'b =
        f (m oc) oc
      let putc (c:char) (oc:out_channel): unit =
        output_char oc c
      let fill (c:char) (n:int) (oc:out_channel): unit =
        for i = 0 to n - 1 do
          output_char oc c
        done
      let put_substring (s:string) (i0:start) (l:length) (oc:out_channel): unit =
        for i = i0 to i0 + l - 1 do
          output_char oc s.[i]
        done
      let put_string (s:string) (oc:out_channel): unit =
        put_substring s 0 (String.length s) oc
      let run (oc:out_channel) (m:'a t): 'a =
        m oc
    end
\end{ocaml}




\begin{thebibliography}{99}

\bibitem{chitil2001} Olaf Chitil. Pretty printing with lazy dequeues. ACM
  Trans. Program. Lang. Syst.  27 (2005) 163–184

\bibitem{hughes1995} John Hughes. The design of a pretty-printing library. In:
  Advanced Functional Programming, First Int. Spring School, Springer-Verlag
  (1995) 53–96

\bibitem{oppen1980} Derek Oppen. Prettyprinting. ACM
  Trans. Program. Lang. Syst. 2 (1980) 465–483

\bibitem{peyton-jones1997} Simon Peyton Jones. Haskell pretty-printer library,
  1997. Available from http://www.haskell.org/libraries/\#prettyprinting.

\bibitem{wadler} Phil Wadler. A prettier printer. In: The Fun of
  Programming. A Symposium in honour of Professor Richard Bird’s 60th
  birthday, Oxford (2003)

\end{thebibliography}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
