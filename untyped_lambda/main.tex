\documentclass{article}

\usepackage{amsmath,amsthm,xcolor,graphicx}
\usepackage[pdftex]{hyperref}







\begin{document}

\input{common}

\title{Lambda Calculus - Step by Step}
\author{Helmut Brandl}
\date{}


\maketitle

\tableofcontents

\section{Motivation}

This is a picture of David
Hilbert:\includegraphics[scale=0.2,angle=90]{../img/hilbert.jpg} This is the text
which follows.


\section{Inductive Sets and Relations}


\begin{definition} The \emph{transitive closure} $\rplus{r}$ of a relation $r$ is
  defined by the rules
1.~$\rulev{r(a,b)}{\rplus{r}(a,b)}$,
2.~$\rulev{\rplus{r}(a,b) \\ r(b,c)}{\rplus{r}(a,c)}$
\end{definition}

\begin{definition} The \emph{reflexive transitive closure} $\rstar{r}$ of a relation $r$ is
  defined by the rules
1.~$\rulev{}{\rstar{r}(a,a)}$,
2.~$\rulev{\rstar{r}(a,b) \\ r(b,c)}{\rstar{r}(a,c)}$
\end{definition}

\begin{definition} The \emph{equivalence closure} $\reqv{r}$ of a relation $r$ is
  defined by the rules
  1.~$\rulev{}{\reqv{r}(a,a)}$,
  2.~$\rulev{\reqv{r}(a,b)
    \\ r(b,c)} {\reqv{r}(a,c)}$,
  3.~$\rulev{\reqv{r}(a,b) \\ r(c,b)} {\reqv{r}(a,c)}$
\end{definition}

\begin{theorem}
  All closures are increasing $r \subseteq r^c$, monotonic
  $r \subseteq s \imp r^c \subseteq s^c$ and idempotent $r^{cc} = r$. Proof
  e.g. for the reflexive transitive closure. TBD.
\end{theorem}

\begin{theorem}
A relation $s$ which satisfies $r \subseteq s \subseteq r^c$ has the same closure
as $r$ i.e. $r^c = s^c$. Proof:
  \begin{itemize}
  \item $r^c \subseteq s^c$ by monotonicity.
  \item $s^c \subseteq r^c$: $s^c \subseteq r^{cc}$ by
    monotonicity and then use idempotence to conclude $s^c \subseteq r^c$.
  \end{itemize}
\end{theorem}



Theorems: $\rplus{r}$ is transitive, $\rstar{r}$ is transitive, $\reqv{r}$ is
symmetric, $\rplus{r}\subseteq\rstar{r}$, $r$ reflexive $\imp \rplus{r} =
\rstar{r}$.


\begin{definition}
  $a$ is a \emph{terminal element} of the relation $\to$ if it has no
  successor i.e. $\forall b: \neglow a \to b$.
\end{definition}

\begin{definition}
  $a$ is a \emph{terminating element} of the relation $\to$ if there is a path
  to a terminal element $b$ i.e. $a \tostar b$.
\end{definition}

\begin{definition}
A relation $\to$ is a \emph{diamond} if for all $a$, $b$ and $c$ there exists a $d$
such that
$
  \begin{matrix}
    a & \to & b \\
    \downarrow & & \downarrow \\
    c & \to & \exists d
  \end{matrix}
$
\end{definition}


\begin{definition}
  A relation $r$ is \emph{confluent} if $\rstar{r}$ is a diamond.
\end{definition}

\begin{theorem} In a confluent relation $r$ all two $r$-equivalent elements
  meet at some common element
  $
  \begin{matrix}
    a & \reqv\to & b \\
    & \rstar\searrow & \downarrow_*\\
    & & \exists c
  \end{matrix}
  $.
  Proof by induction on $a\reqv\to b$.
  \begin{enumerate}

  \item $a = b$. Trivial. Take $c = a$.

  \item
    $\begin{matrix}
      a & \reqv\to & b & \to & c\\
      & \rstar\searrow & \downarrow_*  & & \downarrow_*\\
      & & d? & \rstar\to & e?
    \end{matrix}$.
    $d$ exists by induction hypothesis, $e$ exists by confluence.

  \item
    $
    \begin{matrix}
      a & \reqv\to & b & \gets & c\\
      & \rstar\searrow & \downarrow_*  & & \downarrow_*\\
      & & d? & \rstar\to & e?
    \end{matrix}
    $.
    $d$ exists by induction hypothesis, $e$ exists by confluence.
  \end{enumerate}
\end{theorem}

Definition: $a$ is a terminal element of $r$ if $\neg r(a,b)$ for all $b$.

Definition: Set $\overline T$ of terminating elements of a relation $r$:
$\rulev{a\in T}{a\in \overline T}$, $\rulev{r(a,b) \\ b\in\overline T}{a\in
  \overline T}$ where $T$ is the set of terminal elements. By definition: For
all terminating elements $a$ there is a terminal element $b$ with $\rstar
r(a,b)$.

Theorem: In a confluent relation all terminating elements have a unique
terminal element. Proof: Suppose there are two terminal elements $b$ and $c$
for the terminating element $a$. By definition there must be a $d$ such that
$\begin{matrix} a & \tostar & b \\
  \downarrow_* & & \downarrow_* \\
  c & \tostar & d
\end{matrix}$
which contradicts the assumption that $b$ and $c$ are terminal.


Theorem: In a confluent relation $r$ two $r$-equivalent terminating elements have the same
terminal element.
Proof: Assume $a \reqv\to b$ and $a \to_* c$ and $b \to_* d$
where $c$ and $d$ are different terminal elements. Prove by induction on $a
\reqv\to b$. Case (a): $a=b$. By the previous theorem the terminal element
must be unique. Contradiction. Case (b): $a \reqv\to b$ and $b \to c$. By
induction hypothesis $a$ and $b$ must have the same terminal element.

Theorem: The reflexive transitive closure of a diamond is a diamond (stripe
lemma).
Proof:
\begin{itemize}
\item Lemma: Let $\to$ be a diamond. Then
$\begin{matrix}
a & \to_* & b \\
\downarrow & & \downarrow \\
c & \to_* & \exists d
  \end{matrix}$.
Proof by induction on $a \to_* b$.
\begin{itemize}
\item Case (a): $a = b$. Trivial, take $d=c$.
\item Case (b):
$\begin{matrix}
a & \to_* & b & \to & c\\
\downarrow & & \downarrow & & \downarrow\\
d & \to_* & e? & \to & f?
\end{matrix}$. $e$ exists by the induction hypothesis, $f$ exists because
$\to$ is a diamond.
\end{itemize}

\item Theorem:  Let $\to$ be a diamond. Then
$\begin{matrix}
a & \to_* & b \\
\downarrow_* & & \downarrow_* \\
c & \to_* & \exists d
  \end{matrix}$. Proof by induction on $a \to_* c$.
\begin{itemize}
\item Case (a): $a = b$. Trivial, take $d=c$.
\item Case (b):
$\begin{matrix}
a & \to_* & b\\
\downarrow_* & & \downarrow_* \\
c & \to_* & e?  \\
\downarrow & & \downarrow \\
d & \to_* & f?
\end{matrix}$. $e$ exists by induction hypothesis, $f$ exists by the previous lemma.
\end{itemize}
\end{itemize}



\section{Lambda Terms}

\begin{definition}
  Let $x$ range over a countably infinite set of variable names then the set
  of lambda terms is defined by the grammar $$t ::= x \mid t t \mid \lambda x. t$$.
\end{definition}

A lambda term is either a variable $x$, an application $a b$ (the term $a$
applied to the term $b$) or an abstraction $\lambda x.a$.

We use the convention that application is left associative i.e. $a b c$ is
parsed as $(a b) c$.

Nested lambda abstractions $\lambda x. \lambda y. \ldots . t$ are parsed as
$\lambda x. (\lambda y. \ldots . t)$ and abbreviated as $\lambda x y \ldots . t$

\begin{definition}
  The set of free variables $FV(t)$ of a lambda term $t$ is defined by
  $$FV(t) :=
  \begin{cases} FV(x) &= \{x\} \\
     FV(a b) &= FV(a) \cup FV(b) \\
     FV(\lambda x. t) &= FV(t) - \{x\}
   \end{cases}
   $$
\end{definition}

The variable $x$ in the term $t$ of the abstraction $\lambda x.t$ is a bound
variable. Bound variables can be renamed arbitrarily. We consider terms equal
which have just different namings of bound variables. E.g. the term $\lambda
x.x$ and $\lambda y.y$ are equal.

\begin{definition}
  The variable substitution $a[x:=t]$ is defined by
  $$a[x:=t]~:=
  \begin{cases} x[x:=t]  &:= t \\
    y[x:=t] &:= y \quad \text{for}\quad x \ne y \\
    (a b)[x:=t] &:= a[x:=t] \, b[x:=t] \\
    (\lambda y.a)[x:=t]  &:= \lambda y. a[x:=t] \quad\text{for}\quad x \ne y
    \land y \notin FV(t)
   \end{cases}
   $$
\end{definition}

Note: The condition on the last line is no restriction because we can always
rename the bound variable $y$ to a fresh variable $z$ different from $x$ and
not occuring free in $t$ since there are infinitely many variables available.

Two subsequent substitutions do not commute. The terms $a[x:=b][y:=c]$ and
$a[y:=c][x:=b]$ are different in general even if $x \ne y$ and
$x \notin FV(c)$. Reason: Neither $a[x:=b][y:=c]$ nor $a[y:=c]$ do contain any
$y$. But $b$ might contain $y$ and therefore $a[y:=c][x:=b]$ might contain
$y$. In order to make the swapping correct we have to do the substitution
$b[y:=c]$ before substituting the variable $x$ by $b$.

\begin{theorem} Substitution lemma: Let $x \ne y$ and $x \notin
  FV(c)$. Then $$a[x:=b][y:=c] = a[y:=c]\big[x:= b[y:=c]\big]$$. Proof by
  induction on the structure of $a$. We use the abbreviations
  $$\begin{array}{ll}
      s_1(a) &:= a[x:=b][y:=c] \\
      s_2(a) &:= a[y:=c]\big[x:=b[y:=c]\big]
    \end{array}$$.
  \begin{enumerate}
  \item $a$ is a variable. Lets call it $z$. To prove $s_1(z) = s_2(z)$
    \begin{itemize}
    \item $z \ne x \land z \ne y$: $s_1(z) = z = s_2(z)$
    \item $z = x \land z \ne y$: $s_1(z) = b[y:=c] = s_2(z)$
    \item $z \ne x \land z = y$: $s_1(z) = c = s_2(z)$
    \end{itemize}
  \item $a$ is the application $t u$.
    $$\begin{array}{llll}
        s_1(t u) &=& s_1(t) s_1(u) & \text{definition of substitution}\\
       &=& s_2(t) s_2(u) & \text{induction hypothesis}\\
        &=& s_2(t u) & \text{definition of substitution}
      \end{array}$$
      with the abbreviations $s_1(v) := v[x:=b][y:=c]$ and $s_2(v) :=
      v[y:=c][x:=b[y:=c]]$.
    \item $a$ is the abstraction $\lambda z.t$.
    $$\begin{array}{llll}
        s_1(\lambda z. t) &=& \lambda z. s_1(t)  & \text{definition of substitution}\\
       &=& \lambda z. s_2(t) & \text{induction hypothesis}\\
        &=& s_2(\lambda z.t) & \text{definition of substitution}
      \end{array}$$
      with appropriate renaming of the bound variable $z$ in order to avoid
      variable capture.
  \end{enumerate}
\end{theorem}

\begin{definition} \emph{Beta reduction} $\tobeta$ is a relation defined over lambda
  terms by the rules
  \begin{enumerate}
  \item $(\lambda x.a) b \tobeta a[x := b]$
  \item $\rulev{a\tobeta b}{a c \tobeta b c}$
  \item $\rulev{b\tobeta c}{a b \tobeta a c}$
  \item $\rulev{a \tobeta b}{\lambda x.a \tobeta \lambda x.b}$
  \end{enumerate}
\end{definition}

\section{Church Rosser - Confluence}

\begin{definition} \emph{Parallel beta reduction} $\tobetap$ is a relation
  defined over lambda terms by the rules
  \begin{enumerate}
  \item $a \tobetap a$
  \item $\rulev{a \tobetap b} {\lambda x.a \tobetap \lambda x.b}$
  \item $\rulev{a\tobetap c \\ b \tobetap d}{a b \tobeta c d}$
  \item $\rulev{a\tobetap c \\ b \tobetap d}{(\lambda x.a) b \tobetap c[x := d]}$
  \end{enumerate}
\end{definition}

In order to prove that $\tobetap$ is a diamond we need some lemmas.

\begin{lemma}
  Parallel beta reduction preserves abstractions i.e.
  $\lambda x.a \tobetap c \imp \exists b : a \tobetap b \land c = \lambda
  x.b$. Proof by induction on $\tobetap$.
  \begin{enumerate}
  \item $c = \lambda x.a$. Trivial. Take $b = a$.
  \item $\lambda x.a \tobetap \lambda x.b$ with $a \tobetap b$. Trivial. Take $b$.
  \item The case $\lambda x.a = t u$ is syntactically impossible. Abstraction
    and application are different.
  \item The case $\lambda x.a = (\lambda x.u) v$ is syntactically
    impossible. Abstraction and application are different.
  \end{enumerate}
\end{lemma}


\begin{lemma}
  $t \tobetap u \imp a[x := t] \tobetap a[x := u]$. Proof by induction on the
  structure of $a$.
  \begin{enumerate}
  \item $a$ is a variable. To prove: $z[x := t] \tobetap z[x := u]$. Case $z=x$
    is satisfied because of the assumption $t \tobetap u$. Case $z\ne x$ is
    satisfied by reflexivity $z \tobetap z$.
  \item  $a$ is an application $b\, c$.
    $$
    \begin{array}{llll}
      (b c)[x:=t] &=& b[x:=t]\, c[x:=t] &\text{definition of substitution}\\
      &\tobetap & b[x:=u]\, c[x:=u] &\text{ind hypo + rule 3} \\
      &=& (b c)[x:=u] & \text{definition of substitution}
    \end{array}
    $$
  \item  $a$ is an abstraction $\lambda y.b$.
    $$
    \begin{array}{llll}
      (\lambda y.b)[x:=t] &=& \lambda y. b[x:=t]  &\text{definition of substitution}\\
      &\tobetap & \lambda y.b[x:=u] &\text{ind hypo + rule 2} \\
      &=& (\lambda y.b)[x:=u] & \text{definition of substitution}
    \end{array}
    $$
  \end{enumerate}
\end{lemma}

\begin{lemma}
  % a -> c and b -> d  =>  a[x:=b] -> c[x:=d]
  % ----------------------------------
  $a \tobetap c \land b \tobetap d  \imp a[x := b] \tobetap c[x := d]$. Proof
  by induction on $a \tobetap c $.
  \begin{enumerate}
  \item
    $a=c$. Prove by the previous lemma.
  \item
    $\lambda y.a \tobetap \lambda y.c$. Premise $a \tobetap c$. Induction
    hypothesis $a[x := b] \tobetap c[x := d$
    $$
    \begin{array}{llll}
      (\lambda y.a)[x := b]  &=& \lambda y.a [x := b] &\text{definition substitution}\\
                             &\tobetap& \lambda y.c[x := d] &\text{induction hypo + rule 2} \\
                             &=& (\lambda y.c)[x := d] &\text{definition substitution}
    \end{array}
    $$.
  \item
    $a e \tobetap c f$.
    Premises $a\tobetap c, e\tobetap f$.
    Induction hypotheses
      $a[x := b] \tobetap c[x := d],
       e[x := b] \tobetap f[x := d]$
    $$
    \begin{array}{llll}
      (a e)[x := b]  &=& a[x := b]\, e[x := b] &\text{definition substitution}\\
                     &\tobetap& c[x := d] \, f[x := d] &\text{induction hypo + rule 3} \\
                     &=& (c f)[x := d] &\text{definition substitution}
    \end{array}
    $$.
  \item
    $(\lambda y.a) c \tobetap e[y:=f]$.
    Premises $a \tobetap e, c \tobetap f$.
    Induction hypotheses
      $a[x:=b] \tobetap e[x := d],
        c[x:=b]  \tobetap f[x := d]$
    $$
    \begin{array}{llll}
      ((\lambda y.a) c)[x := b]  &=& (\lambda y.a[x := b])\, c[x := b] &
                                                                         \text{definition substitution}\\
                     &\tobetap& e[x := d]\big[y:=f[x := d]\big] &
                                                                  \text{induction hypo + rule 4} \\
                     &=& \big(e[y:=f]\big)[x := d] &
                                                                  \text{substitution
                                                           swap lemma}
    \end{array}
    $$
  \end{enumerate}
\end{lemma}





\begin{theorem}
  Parallel reduction $\tobetap$ is a diamond i.e.
  %------------------------------------
  $\begin{matrix}
    a & \tobetap & b \\
    \downarrow_p & & \downarrow_p \\
    c & \tobetap & \exists d
  \end{matrix}
  $.
  Proof by induction on $a \tobetap b$.
  xs\begin{enumerate}
  \item
    $a=b$. Use $d = c$.

  \item
    $\lambda x.a \tobetap \lambda x.b$. Premise $a \tobetap b$.
    Goal $
    \begin{matrix}
      \lambda x.a & \tobetap & \lambda x.b \\
      \downarrow_p & & \downarrow_p \\
      c & \tobetap & ?
    \end{matrix}    $.
    Parallel reduction preserves
    abstraction. Therefore $\lambda x.a \tobetap c$ implies some $d$ with $a
    \tobetap d$ and $c = \lambda x.d$.
    Induction hypothesis $
    \begin{matrix}
    a & \tobetap & b \\
    \downarrow_p & & \downarrow_p \\
    d & \tobetap & \exists e
  \end{matrix}$.
  Using $d$ and $e$ we get $
  \begin{matrix}
    \lambda x.a & \tobetap & \lambda x.b \\
    \downarrow_p & & \downarrow_p \\
    \lambda x.d & \tobetap & \lambda x.e
  \end{matrix} $

  \item
    $a e \tobetap b f$.
    Premises $a \tobetap b, e \tobetap f$.
    Goal $
    \begin{matrix}
      a e & \tobetap & b f \\
      \downarrow_p & & \downarrow_p \\
      c & \tobetap & ?
    \end{matrix}$.
    Proof bysubinduction on $a e \tobetap c$.
    \begin{enumerate}
    \item
      $c = a e$. Use $b f$.
    \item
      Syntactically impossible, because $a e$ is not an abstraction.
    \item
      $a e \tobetap g h$.
      Premises $a \tobetap g, e \tobetap h$.
      Induction hypotheses $
      \begin{matrix}
        a & \tobetap & b \\
        \downarrow_p & & \downarrow_p \\
        g & \tobetap & \exists i
      \end{matrix}$
      ,
      $\begin{matrix}
        e & \tobetap & h \\
        \downarrow_p & & \downarrow_p \\
        h & \tobetap & \exists k
      \end{matrix}$.
      Therefore we get $
      \begin{matrix}
        a e & \tobetap & b f \\
        \downarrow_p & & \downarrow_p \\
        g h & \tobetap & i k
      \end{matrix}$.
    \item
      $(\lambda x.a) e \tobetap g[x:=h]$.
      \begin{itemize}
      \item Goal $
        \begin{matrix}
          (\lambda x.a) e & \tobetap & b f \\
          \downarrow_p & & \downarrow_p \\
          g[x:=h] & \tobetap & ?
        \end{matrix}$.
      \item Premises $a \tobetap g, e \tobetap h$.
      \item Outer premises $\lambda x.a \tobetap b, e \tobetap f$
      \item Induction hypothesis
        $\begin{matrix}
          e & \tobetap & f \\
          \downarrow_p & & \downarrow_p \\
          h & \tobetap & \exists k
        \end{matrix}
        $.
      \item Parallel reduction preserves abstraction. Therefore there is some
        $m$ with $b = \lambda x.m, a \tobetap m, \lambda x.a \tobetap \lambda
        x.m$.
      \item Induction hypothesis $
        \begin{matrix}
          a & \tobetap & m \\
          \downarrow_p & & \downarrow_p \\
          g & \tobetap & \exists n
        \end{matrix}$.
      \item We get $
        \begin{matrix}
          (\lambda x.a) e & \tobetap & (\lambda x.m) f \\
          \downarrow_p & & \downarrow_p \\
          g[x:=h] & \tobetap & n[x:=k]
        \end{matrix}$
      \end{itemize}
\end{enumerate}
  \item
    $(\lambda x.a) e \tobetap b[x:=f]$.
    Goal $
    \begin{matrix}
      (\lambda x.a) e &\tobetap& b[x:=f] \\
      \downarrow_p & & \downarrow_p \\
      c &\tobetap & \exists d
    \end{matrix}
    $.
    Premises $a \tobetap b, e \tobetap f$.
    Proof by subinduction on $(\lambda x.a) e \tobetap c$
    \begin{enumerate}
    \item
      $c = (\lambda x.a) e$. Use $d = (\lambda x.b) f$
    \item Syntactically impossible because $(\lambda x.a) e$ is an
      application and not an abstraction.
    \item
      $(\lambda x.a) e \tobetap g h$
      \begin{itemize}
      \item Goal $
        \begin{matrix}
          (\lambda x.a) e &\tobetap& b[x:=f] \\
          \downarrow_p & & \downarrow_p \\
          g h &\tobetap & \exists d
        \end{matrix}$
      \item Premises $\lambda x.a \tobetap g, e \tobetap h$.
      \item Induction hypothesis $
        \begin{matrix}
          e &\tobetap& f \\
          \downarrow_p & & \downarrow_p \\
          h &\tobetap & \exists i
        \end{matrix}$
      \item $\tobetap$ preserves abstraction, therefore there is some $k$ with
        $g = \lambda x.k, a \tobetap k$.
      \item Induction hypothesis
        $\begin{matrix}
          a &\tobetap& b \\
          \downarrow_p & & \downarrow_p \\
          k &\tobetap & \exists m
        \end{matrix}$
      \item We get $
        \begin{matrix}
          (\lambda x.a) e &\tobetap& b[x:=f] \\
          \downarrow_p & & \downarrow_p \\
          (\lambda x.k) h &\tobetap & m[x:=i]
        \end{matrix}$
      \end{itemize}
    \item
      $(\lambda x.a) e \tobetap g[x:=h]$
      \begin{itemize}
      \item Goal $
        \begin{matrix}
          (\lambda x.a) e &\tobetap& b[x:=f] \\
          \downarrow_p & & \downarrow_p \\
          g[x:=h] &\tobetap & \exists d
        \end{matrix}$
      \item Premises $a \tobetap g, e \tobetap h$.
      \item Induction hypotheses $
        \begin{matrix}
          a &\tobetap& b \\
          \downarrow_p & & \downarrow_p \\
          g &\tobetap & \exists m
        \end{matrix},\,
        \begin{matrix}
          e &\tobetap& f \\
          \downarrow_p & & \downarrow_p \\
          h &\tobetap & \exists i
        \end{matrix}$
      \item
        We get  $
        \begin{matrix}
          (\lambda x.a) e &\tobetap& b[x:=f] \\
          \downarrow_p & & \downarrow_p \\
          g[x:=h] &\tobetap & m[x:=i]
        \end{matrix}$
      \end{itemize}
    \end{enumerate}
  \end{enumerate}
\end{theorem}

\section{Reduction Strategies}

\section{Computations}

\section{Undecidability}


\include{bibliography}

\end{document}
