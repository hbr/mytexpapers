\section{Proof of Strong Normalization}

\subsection{Overview}

The goal of this section is to prove that all legal terms for all type systems
of the lambda cube are strongly normalizing i.e.

$$
\ruleh{\Gamma \vdash t: T}{t \in \SN}.
$$

The proof has many steps and it is easy to get lost in the details. Therefore
we give an overview and a motivation for the different proof steps in this
section.

\paragraph{Naive Proof Attempts}
All naive proof attempts by induction on $\Gamma \vdash t: T$ must fail,
because there is no chance to prove
$\ruleh{f \in \SN \quad a \in \SN}{f a \in \SN}$. Counterexample: Take the
mockingbird combinator $M := \lambda x. x x$ which is definitely in strongly
normalizing because it is in normal form. Then we get
$$
  M M \reduce M M \reduce M M \reduce \ldots.
$$
i.e. the application of a strongly normalizing term to a strongly normalizing
term is a term which is no longer normalizing. You might argue that $M M$ is
not typeable and you might even be able to prove that. Then I can come up with
the Turing combinator $U := \lambda x f . f (x x f)$ which has the infinite
reduction sequence
$$
 U U f \reduce f (U U f) \reduce \ldots \reduce f^n (U U f) \reduce \ldots
$$
for arbitrary terms $f$.

We have to strengthen the goal $t \in \SN$ in order to get stronger induction
hypotheses. One idea for a stronger goal can be found by looking at the
reduction rule $(\lambda x^A. e) a \reduce e[x:=a]$. If we can prove not only
that $e$ is strongly normalizing but also that $e[x:=a]$ is strongly
normalizing for valid terms $a$ we are one step further.


\paragraph{Substitutions}
In the proof we work with substitutions $\rho = [x_1:u_1, x_2:u_2, \ldots]$
such that $\rho(t)$ is the term $t$ where all variables $x_i$ are
simultaneously substituted by the corresponding term $u_i$. Since $t$ can
contain only variables of the context $\Gamma$ only substitutions for the
variables in $\Gamma$ are needed.

\paragraph{Models}
We must require not only that the terms $u_i$ are strongly normalizing, but
also that all $u_i$ are drawn from a set of terms which we call a model of
$t$'s type $T$. I.e. we need another function $\xi$ which maps types $T$ to
sets of strongly normalizing terms $\xi(T)$.

We define a substitution $\rho$ and a model map $\xi$ to satisfy the context
$\Gamma$ which we abbreviate by $\rho,\xi \vDash \Gamma$, if $\rho(x) \in
\xi(T)$ for all variables of the context. If we can prove the soundness
theorem
$$
\rulev
{
  \Gamma \vdash t : T
  \\
  \rho,\xi \vDash \Gamma
}
{\rho(t) \in \xi(T)}
$$
and that the identity substitution is always one of the possibilities, then we
are done.

\paragraph{Closure Condition for  Models}
In order to be able to use the identity substitution we have to stipulate that
$\xi(T)$ for all valid types $T$ contain all variables of the context. But we
need more. Because of the subject reduction rule the terms $(\lambda x^A. e)
a$ and $e[x:=a]$ have the same type we must make that both are contained in
the model of the corresponding type. But also $(\lambda x^A.e) a b c \ldots$
and $e[x:=a] b c \ldots$ have the same type. So both have to be contained or
both must not be contained in a valid model for a type. Using some closure
conditions for a type model we require that each model of a type is a
saturated set of strongly normalizing terms.


\paragraph{Functions as Models}
It is not sufficient to assign an arbitrary saturated set of strongly
normalizing terms as a model to a type because we have type
constructors. E.g. $\List$ is not a valid type, but $\List\,\Nat$ is a valid
type. The predicate $\even$ is not a type, but $\even\,n$ where $n:\Nat$ is a
valid typing judgement.

In the first case we need as a model of $\List$ a function which maps a model
into a model. And depending on the model $\xi(T)$ we have to get a model
$\xi(\List\,T)$ which must be equal to $\xi(\List) (\xi(T))$.

In the second case we do not need a function as a model for $\even$, because
the number $n$ is not a type and therefore does not need and does not have a
model.


\paragraph{Model Sets}
In the proof we are going to build the function $\xi$ from an assignment of
models to variables i.e. from the base form $\xi = [x_1:M_1, x_2:M_2,\ldots]$
where $\xi$ assigns models to some variables of a context $\Gamma$. Note that
the \emph{variable} rule of the typing relation reads
$$
\rulev
{\Gamma \vdash A:s
\\ x \notin \Gamma}
{\Gamma,x:A \vdash x :A}.
$$

In case of $s = *$ we do not need a model for $x$, because $x$ is neither a
type nor a type constructor. However if $s = \Box$ then $x$ is either a type
(if $A = *$) or a type constructor (e.g. if $A = \Pi y^B.*$).

In order to assign model the variable which need a model we need a function
$\nu$ which assigns to each term $A$ which satisfies $\Gamma \vdash A:\Box$
(we call such terms $A$ $\Kinds$) a model set $\nu(A)$ which is either a set
of saturated sets or a set of functions from models to models.

Remember: A model is either a saturated set of terms or a function of a models
to models. A model set is either a set of saturated sets or a set of functions
from models to models.

\paragraph{From Model Assignments to Models}
Having this function $\nu$ we can select a model for each variable $x$ of a
context $\Gamma$ whose type is a kind i.e. we can define a selection
$\xi = [x_1:M_1, x_2:M_2,\ldots]$ which is valid for the context. Then we
define a ternary relation $\xi \Vdash T : M$ which says that $M$ is a valid
model for the term $T$ under the model assignment $\xi$.

Further we have to prove that for each $\Gamma \vdash t:T$ there is a model
assignment $\xi$ and a model $M$ which satisfies $\xi \Vdash T:M$ and that the
assignment $\xi$ uniquely determines the model $M$. Having this we can treat
the model assignment $\xi$ as a function which maps each valid type $T$ with
$\Gamma \vdash t:T$ into a model for the type $T$ which is a saturated set of
terms.




\subsection{Saturated Sets}

\begin{definition} % Base terms
  The set of base terms $\BT$ is defined inductively by the rules
  \begin{enumerate}

  \item $x \in \BT$

  \item $\ruleh{a \in \BT \quad b \in \SN}{a b \in \BT}$
  \end{enumerate}
\end{definition}


\begin{lemma}
  \label{BTSN}
  Base terms are strongly normalizing $\ruleh{a \in \BT}{a \in \SN}$.
\end{lemma}








\begin{definition} % Key reduction
  The relation \emph{key reduction} denoted by the binary operator
  $\keyreduce$ is defined inductively by the rules
  \begin{enumerate}

  \item $(\lambda x^A.e) a \keyreduce e[x:=a]$

  \item $\ruleh{a \keyreduce b}{a c \keyreduce b c}$
  \end{enumerate}
\end{definition}

I.e. key reduction is possible only if the term is an application and the
leftmost application is a redex.






\begin{definition} % Saturation
  A saturation of a set $S$ of terms $S^\sat$ is a closure defined inductively
  by the rules
  \begin{enumerate}

  \item $\ruleh{a \in S}{a \in S^\sat}$

  \item $\ruleh{a \in \BT}{a \in S^\sat}$

  \item $\ruleh
    {a \keyreduce b \quad a \in \SN \quad b \in S^\sat}
    {a \in S^\sat}$
  \end{enumerate}
\end{definition}

\begin{definition}
  The set $\SAT$ of all saturated sets is defined by
  $$
  \SAT := \{S \mid  S^\sat \subseteq S \land S \subseteq \SN \}
  $$
\end{definition}


\begin{lemma}
  \label{SNinSAT}
  The set of strongly normalizing terms is saturated i.e. $\SN \in \SAT$.

  \begin{proof} Since $\SN \subseteq \SN$ is satisfied trivially we have to
    prove the condition
    $$
    \ruleh{a \in \SN^\sat}{a \in \SN}
    $$
    which we prove by induction on $a \in \SN^\sat$.

    \begin{enumerate}
    \item $\ruleh{a \in \SN}{a \in \SN^\sat}$. Goal $a \in \SN$. Trivial by
      assumption.

    \item $\ruleh{a \in \BT}{a \in S^\sat}$. Goal $a \in \SN$. By lemma
      \emph{base terms are strongly normalizing}~\ref{BTSN}

    \item $\ruleh
      {a \keyreduce b \quad a \in \SN \quad b \in S^\sat}
      {a \in \SN^\sat}$: Goal $a \in \SN$. Trivial by assumption.
    \end{enumerate}
  \end{proof}
\end{lemma}





\subsection{Arities and Kinds}

\begin{definition} % Arity
  $\Ar$ is a relation such that $Ar(A,s,n)$ states that the term $A$ is an
  aritiy of sort $s$ with $n$ arguments.

  \begin{enumerate}

  \item $\Ar(s,s,0)$

  \item $\ruleh{\Ar(B,s,n)}{Ar(\Pi x^A.B, s, 1+n)}$
  \end{enumerate}

\end{definition}



\begin{lemma}
  \label{reductionpreservesarity}
  Reduction preserves arity
  $$
  \rulev{\Ar(T,s,n) \\ T \reduce U}{\Ar(U,s,n)}
  $$
  \begin{proof}
    MISSING!!!
  \end{proof}
\end{lemma}


\begin{definition} % Kinds
  The set of $\Kinds$ is defined inductively by the rules

  \begin{enumerate}

  \item $s \in \Kinds$

  \item $\rulev{B \in \Kinds}{\Pi x^A.B \in \Kinds}$

  \item $\rulev{U \in \Kinds \\ T \reduce U }{T \in \Kinds}$

  \end{enumerate}
\end{definition}


\begin{lemma}
  \label{kindisarity}
  For every kind there exists a corresponding arity.
  $$
  \ruleh{T \in \Kinds}{\exists U s n. T \reducestar U \land \Ar(U,s,n)}
  $$
  \begin{proof}
    By induction on $T \in \Kinds$.
    \begin{enumerate}

    \item $s \in \Kinds$: Trivial by $\Ar(s,s,0)$.


    \item $\rulev{B \in \Kinds}{\Pi x^A.B \in \Kinds}$:
      We get the induction hypothesis
      $ \exists C s n. B \reducestar C \land \Ar(C,s,n)
      $.
      From this we can conclude $\Pi x^A.B \reducestar \Pi x^A.C$ and $\Ar(\Pi
      x^A.C, s, n+1)$ which proves the goal.


    \item $\rulev{U \in \Kinds \\ T \reduce U }{T \in \Kinds}$:

      We get the induction hypothesis
      $\exists Csn. U \reducestar C \land \Ar(C,s,n)$. From the second premise
      $T \reducestar C$ is immediate which proves the goal
    \end{enumerate}
  \end{proof}
\end{lemma}



\begin{lemma}
  In the calculus of constructions every term of type $\Box$ is a kind
  $$
  \ruleh {\Gamma \vdash K: \Box}{K \in Kinds}
  $$
\end{lemma}



\subsection{Model Sets}

\begin{definition} % Models
  A model is either a set of terms or a function mapping a set of models to
  another set of models
\end{definition}


\begin{definition} %nu relation
  The relation $\nu$ between kinds and sets of models is defined inductively
  by the rules
  \begin{enumerate}
  \item $\nu(s,\SAT)$

  \item $\rulev
    {A \notin \Kinds \\ \nu(B,\widehat{M}_B)}
    {\nu(\Pi x^A.B, \widehat{M}_B)}$

  \item $\rulev
    { \nu(B,\widehat{M}_A) \\ \nu(B,\widehat{M}_B)}
    {\nu(\Pi x^A.B, \{f \mid f: \widehat{M}_A \to \widehat{M}_B)\}}$
  \end{enumerate}
\end{definition}



\subsection{Models}