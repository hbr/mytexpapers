\section{Proof of Strong Normalization}

\subsection{Overview}

The goal of this section is to prove that all legal terms for all type systems
of the lambda cube are strongly normalizing i.e.

$$
\ruleh{\Gamma \vdash t: T}{t \in \SN}.
$$

The proof has many steps and it is easy to get lost in the details. Therefore
we give an overview and a motivation for the different proof steps in this
section.

\paragraph{Naive Proof Attempts}
All naive proof attempts by induction on $\Gamma \vdash t: T$ must fail,
because there is no chance to prove
$\ruleh{f \in \SN \quad a \in \SN}{f a \in \SN}$. Counterexample: Take the
mockingbird combinator $M := \lambda x. x x$ which is definitely in strongly
normalizing because it is in normal form. Then we get
$$
  M M \reduce M M \reduce M M \reduce \ldots.
$$
i.e. the application of a strongly normalizing term to a strongly normalizing
term is a term which is no longer normalizing. You might argue that $M M$ is
not typeable and you might even be able to prove that. Then I can come up with
the Turing combinator $U := \lambda x f . f (x x f)$ which has the infinite
reduction sequence
$$
 U U f \reduce f (U U f) \reduce \ldots \reduce f^n (U U f) \reduce \ldots
$$
for arbitrary terms $f$.

We have to strengthen the goal $t \in \SN$ in order to get stronger induction
hypotheses. One idea for a stronger goal can be found by looking at the
reduction rule $(\lambda x^A. e) a \reduce e[x:=a]$. If we can prove not only
that $e$ is strongly normalizing but also that $e[x:=a]$ is strongly
normalizing for valid terms $a$ we are one step further.


\paragraph{Substitutions}
In the proof we work with substitutions $\rho = [x_1:u_1, x_2:u_2, \ldots]$
such that $\rho(t)$ is the term $t$ where all variables $x_i$ are
simultaneously substituted by the corresponding term $u_i$. Since $t$ can
contain only variables of the context $\Gamma$ only substitutions for the
variables in $\Gamma$ are needed.

\paragraph{Models}
We must require not only that the terms $u_i$ are strongly normalizing, but
also that all $u_i$ are drawn from a set of terms which we call a model of
$t$'s type $T$. I.e. we need another function $\xi$ which maps types $T$ to
sets of strongly normalizing terms $\xi(T)$.

We define a substitution $\rho$ and a model map $\xi$ to satisfy the context
$\Gamma$ which we abbreviate by $\rho,\xi \vDash \Gamma$, if $\rho(x) \in
\xi(T)$ for all variables of the context. If we can prove the soundness
theorem
$$
\rulev
{
  \Gamma \vdash t : T
  \\
  \rho,\xi \vDash \Gamma
}
{\rho(t) \in \xi(T)}
$$
and that the identity substitution is always one of the possibilities, then we
are done.

\paragraph{Closure Condition for  Models}
In order to be able to use the identity substitution we have to stipulate that
$\xi(T)$ for all valid types $T$ contain all variables of the context. But we
need more. Because of the subject reduction rule the terms $(\lambda x^A. e)
a$ and $e[x:=a]$ have the same type we must make that both are contained in
the model of the corresponding type. But also $(\lambda x^A.e) a b c \ldots$
and $e[x:=a] b c \ldots$ have the same type. So both have to be contained or
both must not be contained in a valid model for a type. Using some closure
conditions for a type model we require that each model of a type is a
saturated set of strongly normalizing terms.


\paragraph{Functions as Models}
It is not sufficient to assign an arbitrary saturated set of strongly
normalizing terms as a model to a type because we have type
constructors. E.g. $\List$ is not a valid type, but $\List\,\Nat$ is a valid
type. The predicate $\even$ is not a type, but $\even\,n$ where $n:\Nat$ is a
valid typing judgement.

In the first case we need as a model of $\List$ a function which maps a model
into a model. And depending on the model $\xi(T)$ we have to get a model
$\xi(\List\,T)$ which must be equal to $\xi(\List) (\xi(T))$.

In the second case we do not need a function as a model for $\even$, because
the number $n$ is not a type and therefore does not need and does not have a
model.


\paragraph{Model Sets}
In the proof we are going to build the function $\xi$ from an assignment of
models to variables i.e. from the base form $\xi = [x_1:M_1, x_2:M_2,\ldots]$
where $\xi$ assigns models to some variables of a context $\Gamma$. Note that
the \emph{variable} rule of the typing relation reads
$$
\rulev
{\Gamma \vdash A:s
\\ x \notin \Gamma}
{\Gamma,x:A \vdash x :A}.
$$

In case of $s = *$ we do not need a model for $x$, because $x$ is neither a
type nor a type constructor. However if $s = \Box$ then $x$ is either a type
(if $A = *$) or a type constructor (e.g. if $A = \Pi y^B.*$).

In order to assign model the variable which need a model we need a function
$\nu$ which assigns to each term $A$ which satisfies $\Gamma \vdash A:\Box$
(we call such terms $A$ $\Kinds$) a model set $\nu(A)$ which is either a set
of saturated sets or a set of functions from models to models.

Remember: A model is either a saturated set of terms or a function of a models
to models. A model set is either a set of saturated sets or a set of functions
from models to models.

\paragraph{From Model Assignments to Models}
Having this function $\nu$ we can select a model for each variable $x$ of a
context $\Gamma$ whose type is a kind i.e. we can define a selection
$\xi = [x_1:M_1, x_2:M_2,\ldots]$ which is valid for the context. Then we
define a ternary relation $\xi \Vdash T : M$ which says that $M$ is a valid
model for the term $T$ under the model assignment $\xi$.

Further we have to prove that for each $\Gamma \vdash t:T$ there is a model
assignment $\xi$ and a model $M$ which satisfies $\xi \Vdash T:M$ and that the
assignment $\xi$ uniquely determines the model $M$. Having this we can treat
the model assignment $\xi$ as a function which maps each valid type $T$ with
$\Gamma \vdash t:T$ into a model for the type $T$ which is a saturated set of
terms.




\subsection{Saturated Sets}


\subsection{Model Sets}



\subsection{Models}